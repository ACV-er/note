# 编译原理

### 1.1.1 编译器和解释器的区别是什么？

> 编译器: 源程序 -> 中间代码 -> 汇编代码 -> 二进制文件。
>
> 解释器: 在runtime（虚拟机）上一条一条解释代码。

### 1.1.2 编译器相对于解释器的优点是什么？解释器相对于编译器的优点是什么？

> 编译器会生成二进制文件，性能通常比解释性语言高。
>
> 解释器可以更加精准地给出错误诊断，因为代码是一行一行运行的。

### 1.1.3 在一个语言处理系统中，编译器产生汇编语言而不是机器语言的好处是什么？

> 一般来说，一个系统会有汇编器可以将汇编语言翻译成机器语言，而汇编语言易于调试。

### 1.1.4 把一种高级语言翻译成另一种高级语言的编译器称为源到源的翻译器。编译器使用C语言作为目标语言有什么好处？

> 大部分操作系统都有C编译器，C作为中间代码可以让源程序在支持C的所有平台运行。

### 1.1.5 描述一下汇编器所要完成的任务。

> 将汇编语言翻译成目标平台的机器语言。

### 1.3.3 略

### 1.6.1 & 1.6.2

> ​      w  x  y  z
>
> a   13 11 13 11
>
> b    9 7 13 11

### 1.6.3 

> 略

### 1.6.4

> 3
>
> 2

### 2.2.1

`S -> SS+|SS*|a`

* 试说明如何使用该文法生成串`aa+a*`

  > S -> SS* -> SS+S* -> aS+S* -> aa+S* -> aa+a*

* 试为这个串构造一棵语法分析树

  > 同 (a + a) * a

* 该文法生成的语言是什么？证明你的答案。

  > 某种后缀表达式。每个操作符的前面必须有两个表达式。

### 2.2.2 下面各个文法生成的语言分别是什么？证明你的每一个答案。

* `S -> 0S1|01`

  > `0{n}1{m}`

* `S -> +SS|-SS|a`

  > 前缀表达式，包含+、-

* $S \to S(S)S|\epsilon$

  > 匹配正确的括号

* $S \to aSbS|bSaS|\epsilon$

  > 匹配包含ab的串，ab的数量一致。

* `S -> a|S+S|SS|S*|(S)`

  > 描述某种匹配规则

### 2.2.3 2.2.2中，哪些文法具有二义性？

> 3 略
>
> 4 如 abab $aS(ba)bS(\epsilon)$ $aS(\epsilon)bS(aS(\epsilon)bS(\epsilon))$
>
> 5 如 S+SS*  理解为 `S+S(SS*)`| `S* -> S+S* -> S+SS*`

### 2.2.4 为下面各语言构造无二义性的上下文无关文法。证明你的文法都是正确的。

* 用后缀方式表达的算术表达式

  > S -> S S op | num

* 用逗号分开的左结合的标识符列表

  > S -> S , id | id

* 用逗号分开的右结合的标识符列表

  > S -> id, S | id

* 后续略，同书本前文