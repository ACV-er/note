# 一致性hash简述

* 一般适用场景，分布式缓存场景下，缓存分布不均，缓存节点增减时位置发生变化的缓存较多。

> * 缓存一般用hash函数散列到不同服务器，但是hash函数不能保证均匀，就可能出现某部分节点负载过高，一些节点基本无量的情况。
>
> * 传统方式可能是 `{idx} = {hash值} mod {节点数} ` 然后缓存命中编号为`idx`的节点，这样当节点增加了之后，如3台到4台，原本的数据hash值为 1 2 3 4 5 6 7。由下演示可以看到，有4个缓存数据发生了移动，移动过程想保证命中需要较为复杂的处理。并且这是最简单的场景，在末尾增加一个节点。如果是B节点被裁撤，那么变化更加复杂，几乎所有的缓存（示例场景中仅有缓存1在原位）都需要移动位置。
>
>   ```
>   初始节点   A       B      C
>   初始缓存  1 4 7   2 5    3 6
>       
>   增加节点
>       
>   变更后节点   A       B      C    D
>   变更后缓存  1 5     2 6    3 7   4
>       
>   裁撤B节点
>       
>   变更后节点   A       C      D
>   变更后缓存  1 4 7   2 5    3 6
>   ```

* 一致性hash可以解决如上两个问题。

> ​        显然，根据`{idx} = {hash值} mod {节点数} ` 这个公示算出的 `idx` 不可能在机器增减时一致，那么同一个缓存在节点增减前后落在同一个节点上的概率很小，并且都需要重新计算hash。所以可以引入一个槽（`slot`）的概念。直接将缓存映射到hash槽中。redis集群槽的数量默认为2^14 = 16384(这个数字意义不大，不必深究)。如此，公式变成了`{idx} = {hash值} mod {槽数} ` ，这样一来，缓存的`idx`与机器的增减就没有关系了。
>
> ​        解决`idx`变化的问题之后，引入了一个新的问题，如何将`idx`和缓存节点（`node`）结合起来，建立映射关系。可以建立如下图。那么引入一个`node4`把它和`[16000, 16383]`联系起来，只需要移动这一部分槽内的缓存和改变映射关系。具体细节可以了解redis的实现。
>
>         ```
>         node1 => [[0,5000]]
>         node2 => [[5001,8000], [16000, 16383]]
>         node3 => [[8001, 16000]]
>         ```

### tips

* 大部分中文社区都将 一致性hash 称为 一致性hash**算法** ，但是很明显这并不是一个算法，而是一个解决方案。一致性hash是对hash的应用。将其理解为`使用的hash算法始终是一致的`比较妥当。

## * 一致性hash的一些概念

* 上文介绍了一致性hash的应用场景和redis实现一致性hash的思路。下面介绍一些一致性hash的术语和概念。

> * hash圆环、映射数据、虚拟节点
> * hash圆环即将hash的散列空间首位相连，就是一个环。缓存节点分布在hash圆环上。
> * 映射数据是找到缓存节点办法，缓存命中hash圆环上的一个点时，从这个点开始，在圆环上顺时针寻找，第一个缓存节点就是存储了该缓存的节点。
> * 虚拟节点可以理解为缓存节点可以在hash圆环上的多个地方。

对于上文redis的映射例子。用一致性hash的例子可以理解为，有三个缓存节点 node1、node2、node3，有一个长16384的hash圆环。node1在5000的位置上，node2在8000和16383的位置上，node2在16000的位置上。有兴趣可以自行画图，描出三个节点的区间。